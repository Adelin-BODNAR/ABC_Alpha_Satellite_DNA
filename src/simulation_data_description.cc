/**
* @file simulation_data_description.cc
* @brief Simulation and data description joined script.
* @author Adelin BODNAR
* @date 02/04/2024
*
* Script used to simulate the successive amplifications and mutations (substitutions of an ancestor monomer and its children then describing the simulated data while bypassing the intermediate writting and reading steps.
*
*/

#include "../include/simulation.hh"
#include "../include/data_description.hh"

#include <Bpp/BppString.h>  //bpp::BppString
#include <Bpp/Numeric/Number.h> //bpp::BppInteger
#include <Bpp/Phyl/Io/Nhx.h>    //bpp::Nhx
#include <Bpp/Phyl/Tree/Node.h> //bpp::Node
#include <Bpp/Phyl/Tree/Tree.h> //bpp::TreeTemplate<bpp::Node>
#include <Bpp/Seq/Alphabet/AlphabetTools.h> //bpp::Alphabet, bpp::AlphabetTools
#include <Bpp/Seq/Io/Fasta.h>   //bpp::Fasta
#include <filesystem>   //std::filesystem::path, std::filesystem::exists, std::filesystem::is_directory
#include <fstream>  //std::ifstream, std::ofstream
#include <getopt.h> //getopt_long
#include <list> //std::list
#include <memory>   //std::shared_ptr<>
#include <string>   //std::string, std::stoi, std::stod
#include <time.h>   //std::time
#include <vector>   //std::vector


/** @brief Parsed arguments structure
* 
* Structure used to store the arguments provided by the user in the command line after parsing.
*/
struct Args {

    int verbose ; /**< Integer used to determine the level of verbosity for the execution of the script */

    std::string input ; /**< String containing the path provided by the user to the input fasta file with the ancestor monomer */
    int max_size ; /**< Number of monomers aimed for in the dataset at the end of the simulation */
    std::string simulation_id ; /**< String used as an identifier of an execution of the simulation script */

    double amplification_rate ; /**< Rate at which each monomer in the dataset is amplified */

    double alpha_amplification_size ; /**< Alpha parameter for the beta distribution used to draw a random value for the amplification size during each amplification event */
    double beta_amplification_size ; /**< Beta parameter for the beta distribution used to draw a random value for the amplification size during each amplification event */
    int min_amplification_size ; /**< Minimum value of the range from which a random value for the amplification size is drawn during each amplification event */
    int max_amplification_size ; /**< Maximum value of the range from which a random value for the amplification size is drawn during each amplification event */

    double alpha_HOR_order ; /**< Alpha parameter for the beta distribution used to draw a random value for the HOR order during each amplification event */
    double beta_HOR_order ; /**< Beta parameter for the beta distribution used to draw a random value for the HOR order during each amplification event */
    int min_HOR_order ; /**< Minimum value of the range from which a random value for the HOR order is drawn during each amplification event */
    int max_HOR_order ; /**< Maximum value of the range from which a random value for the HOR order is drawn during each amplification event */

    double substitution_rate ; /**< Rate at which a substitution event occurs in the sequence of a monomer. */
    double transition_transversion_ratio; /**< Double variable used to store the transition/transversion ratio involved in the initialization of the substitution matrix  (Ratio == 1 is equivalent to the Jukes-Cantor model, ratio != 1 is equivalent to the Kimura 80 model). */

    int nb_orders_tested; /**< Integer used to determine the number of HOR orders for which an average similarity value will be calculated */
    int nb_similarities_calculated_per_order; /**< Integer used to determine the number of monomers that each monomer will be compared to per HOR order value */

    int seed; /**< Integer variable used to initialize the random number generators. */

    int output_option ; /**< Integer variable used to store the otpion chosen by the user for what outputs must be produced. (0 : Monomers dataset only, 1 : Monomers dataset and phylogenetic tree, 2 : Monomers dataset and simulation parameters, 3 : Monomers dataset, phylogenetic tree and simulation parameters) */

    std::string monomers_dataset_output_path ; /**< String containing the path to the output fasta file generated by the script with the monomers from the dataset retaining their spatial organization */
    std::string tree_output_path ; /**< String containing the path to the output NHX file generated by the script with the phylogenic tree retracing the amplification history of the monomers */
    std::string parameters_log_path ; /**< String containing the path to the log file containing the values for the simulation parameters chosen by the user. */

    std::string final_output_path ; /**< String containing the path to the file to which the line containing the parameters and the generated statistics will be added. */

};


/** @brief Parsing the arguments.
*
* Function parsing the arguments provided by the user in the command line and storing them in the structure defined above.
*
* @param argc The number of arguments provided by the user in the command line.
* @param argv The list of arguments provided by the user in the command line.
*
* @return parsed_args an instance of the Args structure containing the arguments provided by the user and used as parameters for multiple parts of the simulation script
*/
Args get_args(int argc, char **argv) {

    //Initializing parsed_args and default values for some of its attributes

    Args parsed_args ;  /**< Variable used to store and return the arguments provided by the user after parsing */

    parsed_args.verbose = 0;   /**< Initializes the default verbosity level at 0 */

    parsed_args.max_size = 15000 ;          /**< Initializes the default max size for the monomers dataset at 15 000 monomers (middle ground between ~30 000 monomers for the largest human chromosome and ~5 000 for the smallest) */
    parsed_args.simulation_id = "no_id" ;   /**< Initializes the default simulation id */
    parsed_args.amplification_rate = 1.0 ;  /**< Initializes the default amplification rate at 1 amplification per monomer per time unit */

    parsed_args.alpha_amplification_size = 1.0 ;    /**< Initializes the default alpha parameter for the amplification size beta distribution at 1 to mimic an uniform distribution with the default beta parameter */
    parsed_args.beta_amplification_size = 1.0 ;     /**< Initializes the default beta parameter for the amplification size beta distribution at 1 to mimic an uniform distribution with the default alpha parameter */
    parsed_args.min_amplification_size = 1 ;        /**< Initializes the default minimum amplification size to 1 to perform at the very least a duplication for each amplification event */
    parsed_args.max_amplification_size = 7500 ;    /**< Initializes the default maximum amplification size */ //TODO : Find the right value and a justification for it.

    parsed_args.alpha_HOR_order = 1.0 ;     /**< Initializes the default alpha parameter for the HOR order beta distribution at 1 to mimic an uniform distribution with the default beta parameter */
    parsed_args.beta_HOR_order = 1.0 ;      /**< Initializes the default beta parameter for the HOR order beta distribution at 1 to mimic an uniform distribution with the default alpha parameter */
    parsed_args.min_HOR_order = 1 ;         /**< Initializes the default minimum HOR order to 1 to also mimic the amplifications resulting to a monomeric organization (layer of monomers amplified for one origin monomer) */
    parsed_args.max_HOR_order = 40 ;        /**< Initializes the default maximum HOR order to 50 monomers since it is not much above 34 monomers the maximum observed yet in humans */

    parsed_args.substitution_rate = 1 ;  /**< Initializes the default substitution rate at 1 substitution per time unit */
    parsed_args.transition_transversion_ratio = 1 ; /**< Initializes the default transition/transversion ratio at 1 to mimic the Jukes-Cantor model. */

    parsed_args.nb_orders_tested = 40; /**< Initializes the default number of HOR orders for which an average similarity value will be calculated at 40. */
    parsed_args.nb_similarities_calculated_per_order = 5; /**< Initializes the default number of monomers that each monomer will be compared to per HOR order value at 5. */

    parsed_args.seed = std::time(0) ; /**< Initializes the default seed at the current time in seconds. */

    parsed_args.output_option = -1 ; /**< Initializes the default output option at 0 to only produce the monomers dataset. */

    std::filesystem::path dir_dataset ; /**< Declares the path variable used to store the path to the directory that will contain the monomers dataset output file. */
    std::filesystem::path dir_tree ;    /**< Declares the path variable used to store the path to the directory that will contain the phylogenetic tree output file. */

    std::filesystem::path dir_parameters_log ;  /**< Declares the path variable used to store the path to the directory that will contain the simulation parameters log file. */

    std::filesystem::path dir_final_output ;  /**< Declares the path variable used to store the path to the directory that will contain the simulation and data description final output file. */


    /**< String containing the help message printed when the -h , --help or a wrong option are provided ny the user */
    const std::string usage = "Usage: \n"
                            "\t./simulation [-h] -i INPUT [-s MAX_SIZE] [--id SIMULATION_ID] [--amplification_rate AMPLIFICATION_RATE] \n"
                            "\t[--alpha_amplification_size ALPHA_AMPLIFICATION_SIZE] [--beta_amplification_size BETA_AMPLIFICATION_SIZE]\n"
                            "\t[--min_amplification_size MIN_AMPLIFICATION_SIZE] [--max_amplification_size MAX_AMPLIFICATION_SIZE]\n"
                            "\t[--alpha_HOR_order ALPHA_HOR_ORDER] [--beta_HOR_order BETA_HOR_ORDER] [--min_HOR_order MIN_HOR_ORDER]\n"
                            "\t[--max_HOR_order MAX_HOR_ORDER] [--substitution_rate SUBSTITUTION_RATE] [--transition_transversion_ratio TRANSITION_TRANSVERSION_RATIO] \n"
                            "\t[--nb_orders_tested NB_ORDERS_TESTED] [--nb_similarities_calculated_per_order NB_SIMILARITIES_CALCULATED_PER_ORDER] [--seed SEED] \n"
                            "\t[--output_option OUTPUT_OPTION] [--monomers_dataset_output_path MONOMERS_DATASET_OUTPUT_PATH] [--tree_output_path TREE_OUTPUT_PATH] \n" 
                            "\t[--parameters_log_path PARAMETERS_LOG_PATH] [--final_output_path FINAL_OUTPUT_PATH] [-v | --verbose | --no-verbose]\n\n"

                            "\toptions:\n\n"

                            "\t-h, --help \n\t\tOption showing this help message and exiting\n\n"

                            "\t-i INPUT, --input INPUT\n"
                            "\t\tArgument defining the input fasta file containing the \n"
                            "\t\tancestor monomer used to perform the simulation \n\n"

                            "\t-s MAX_SIZE, --max_size MAX_SIZE \n"
                            "\t\tArgument defining the max size of the monomers dataset \n"
                            "\t\tbefore the simulation stops \n\n"

                            "\t--id SIMULATION_ID, --simulation_id SIMULATION_ID \n"
                            "\t\tArgument defining the ID used to identify the current \n"
                            "\t\trun of the simulation \n\n"

                            "\t--amplification_rate AMPLIFICATION_RATE \n"
                            "\t\tArgument defining the rate at which monomers \n"
                            "\t\tare amplified in the simulation \n\n"

                            "\t--alpha_amplification_size ALPHA_AMPLIFICATION_SIZE \n"
                            "\t\tArgument defining the alpha of the law allowing to \n"
                            "\t\tdraw randomly the number of new copies each monomer \n"
                            "\t\tinvolved gets during an amplification event \n\n"

                            "\t--beta_amplification_size BETA_AMPLIFICATION_SIZE \n"
                            "\t\tArgument defining the beta of the law allowing to draw \n"
                            "\t\trandomly the number of new copies each monomer \n"
                            "\t\tinvolved gets during an amplification event \n\n"

                            "\t--min_amplification_size MIN_AMPLIFICATION_SIZE \n"
                            "\t\tArgument defining the minimum of the values from which \n"
                            "\t\twe have to draw randomly the number of new copies each \n"
                            "\t\tmonomer involved gets during an amplification event \n\n"

                            "\t--max_amplification_size MAX_AMPLIFICATION_SIZE \n"
                            "\t\tArgument defining the maximum of the values from which \n"
                            "\t\twe have to draw randomly the number of new copies each \n"
                            "\t\tmonomer involved gets during an amplification event \n\n"

                            "\t--alpha_HOR_order ALPHA_HOR_ORDER \n"
                            "\t\tArgument defining the alpha for the law allowing to \n"
                            "\t\tdraw the number of adjacent monomers involved in the \n"
                            "\t\tan amplification event \n\n"

                            "\t--beta_HOR_order BETA_HOR_ORDER \n"
                            "\t\tArgument defining the beta for the law allowing to \n"
                            "\t\tdraw the number of adjacent monomers involved in the \n"
                            "\t\tan amplification event \n\n"

                            "\t--min_HOR_order MIN_HOR_ORDER \n"
                            "\t\tArgument defining the minimum of the values from which \n"
                            "\t\twe have to draw the number of adjacent monomers \n"
                            "\t\tinvolved in the an amplification event \n\n"

                            "\t--max_HOR_order MAX_HOR_ORDER \n"
                            "\t\tArgument defining the maximum of the values from which \n"
                            "\t\twe have to draw the number of adjacent monomers \n"
                            "\t\tinvolved in the an amplification event \n\n"

                            "\t--substitution_rate SUBSTITUTION_RATE \n"
                            "\t\tArgument defining the rate at which nucleotides are substituted \n"
                            "\t\tin the sequence of a monomer during the simulation \n\n"

                            "\t--transition_transversion_ratio TRANSITION_TRANSVERSION_RATIO \n"
                            "\t\tArgument defining the transition/transversion ratio used to initialize the matrix \n"
                            "\t\tnecessary to perform substitutions in the sequence of a monomer during the simulation \n"
                            "\t\t(== 1 is equivalent to the Jukes-Cantor model, != 1 is equivalent to the Kimura 80 model) \n\n"

                            "\t--nb_orders_tested NB_ORDERS_TESTED \n"
                            "\t\tArgument defining the number of HOR orders for which an \n"
                            "\t\taverage similarity value will be calculated \n\n"

                            "\t--nb_similarities_calculated_per_order NB_SIMILARITIES_CALCULATED_PER_ORDER \n"
                            "\t\tArgument defining the number of monomers that each monomer will \n"
                            "\t\tbe compared to per HOR order value \n\n"

                            "\t--seed SEED \n"
                            "\t\tArgument defining the seed used to initialize the random \n"
                            "\t\tnumber generator \n\n"

                            "\t--output_option OUTPUT_OPTION \n"
                            "\t\tArgument defining the output option given by the user and \n"
                            "\t\tused to determine what outputs must be produced \n"
                            "\t\t(-1: Internal simulation output only, 0 : Monomers dataset only, 1 : Monomers dataset and phylogenetic tree, \n"
                            "\t\t2 : Monomers dataset and simulation parameters, 3 : Monomers dataset, phylogenetic tree and simulation parameters) \n\n"

                            "\t--monomers_dataset_output_path MONOMERS_DATASET_OUTPUT_PATH \n"
                            "\t\tArgument defining the path to the monomers dataset \n"
                            "\t\toutput file \n\n"

                            "\t--tree_output_path TREE_OUTPUT_PATH \n"
                            "\t\tArgument defining the path to the phylogenic tree \n"
                            "\t\toutput file \n\n"

                            "\t--parameters_log_path PARAMETERS_LOG_PATH \n"
                            "\t\tArgument defining the path to the log file containing \n"
                            "\t\tthe values chosen for the simulation parameters \n\n"

                            "\t--final_output_path FINAL_OUTPUT_PATH \n"
                            "\t\tArgument defining the path to the final output file containing the values chosen \n"
                            "\t\tfor the simulation parameters and the results of the data description step \n\n"

                            "\t-v, --verbose, --no-verbose \n"
                            "\t\tOptions allowing to print or not the script execution \n"
                            "\t\tsupervision prints (tree and list after each amplification event) \n\n" ;


    /** @brief Long options defining structure
    *
    * Structure used by the function getopt_long to define, parse and link to their short versions the long options for the simulation script.
    */
    const struct option long_options[] =
        {
          // These options donâ€™t set a flag. We distinguish them by their indices. 

          {"id", required_argument, 0, 0},
          {"simulation_id", required_argument, 0, 0},

          {"amplification_rate", required_argument, 0, 0},

          {"alpha_amplification_size", required_argument, 0, 0},
          {"beta_amplification_size", required_argument, 0, 0},
          {"min_amplification_size", required_argument, 0, 0},
          {"max_amplification_size", required_argument, 0, 0},

          {"alpha_HOR_order", required_argument, 0, 0},
          {"beta_HOR_order", required_argument, 0, 0},
          {"min_HOR_order", required_argument, 0, 0},
          {"max_HOR_order", required_argument, 0, 0},

          {"substitution_rate", required_argument, 0, 0},
          {"transition_transversion_ratio", required_argument, 0, 0},

          {"nb_orders_tested", required_argument, 0, 0},
          {"nb_similarities_calculated_per_order", required_argument, 0, 0},

          {"seed", required_argument, 0, 0},

          {"output_option", required_argument, 0, 0},

          {"monomers_dataset_output_path", required_argument, 0, 0},
          {"tree_output_path", required_argument, 0, 0},
          {"parameters_log_path", required_argument, 0, 0},

          {"final_output_path", required_argument, 0, 0},

          //  These options set flags. 

          {"help", no_argument, 0, 'h'},

          {"input", required_argument, 0, 'i'},
          {"max_size", required_argument, 0, 's'},

          {"verbose", no_argument, 0, 'v'},

          {0, 0, 0, 0}
        };

    // getopt_long stores the option index here.
    int option_index;

    int c;

    while ((c = getopt_long (argc, argv, "hi:s:v", long_options, &option_index)) != -1) {

        switch (c)
        {
            case 'i':

                //std::cout << "Input: " << optarg << std::endl;
                if (std::filesystem::exists(optarg)) {
                    //std::cout << "Input file found.\n" << std::endl;
                    parsed_args.input = optarg;
                }else{
                    std::cout << "No such input file.\n" << std::endl;
                    std::cout << usage.c_str();
                    exit(1);
                }

                break;

            case 's':
                
                //std::cout << "Max size: " << optarg << std::endl << std::endl;
                if (std::stoi(optarg) > 0) {
                    parsed_args.max_size = std::stoi(optarg) ;
                }else{
                    std::cout << "Max size value must be > 0." << std::endl << std::endl;
                    std::cout << usage.c_str();
                    exit(1);
                }

                break;

            case 'v':
                
                parsed_args.verbose ++ ;
               
                break;

            case 0 :
                
                switch (option_index){

                    case 0 :
                    case 1 :

                        //std::cout << "Simulation Id: " << optarg << std::endl << std::endl;
                        parsed_args.simulation_id = optarg;

                        break ;
                    
                    case 2 :

                        //std::cout << "Amplification rate: " << optarg << std::endl << std::endl;
                        parsed_args.amplification_rate = std::stod(optarg);

                        if (parsed_args.amplification_rate <= 0) {
                            std::cout << "Amplification rate value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 3 :

                        //std::cout << "Alpha amplification size: " << optarg << std::endl << std::endl;
                        parsed_args.alpha_amplification_size = std::stod(optarg);

                        if (parsed_args.alpha_amplification_size <= 0) {
                            std::cout << "Alpha amplification size value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 4 :

                        //std::cout << "Beta amplification size: " << optarg << std::endl << std::endl;
                        parsed_args.beta_amplification_size = std::stod(optarg);

                        if (parsed_args.beta_amplification_size <= 0) {
                            std::cout << "Beta amplification size value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 5 :

                        //std::cout << "Min amplification size: " << optarg << std::endl << std::endl;
                        parsed_args.min_amplification_size = std::stoi(optarg);

                        if (parsed_args.min_amplification_size <= 0) {
                            std::cout << "Alpha amplification size value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 6 :

                        //std::cout << "Max amplification size: " << optarg << std::endl << std::endl;
                        parsed_args.max_amplification_size = std::stoi(optarg);

                        break;

                    case 7 :

                        //std::cout << "Alpha HOR order: " << optarg << std::endl << std::endl;
                        parsed_args.alpha_HOR_order = std::stod(optarg);

                        if (parsed_args.alpha_HOR_order <= 0) {
                            std::cout << "Alpha HOR order value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 8 :

                        //std::cout << "Beta HOR order: " << optarg << std::endl << std::endl;
                        parsed_args.beta_HOR_order = std::stod(optarg);

                        if (parsed_args.beta_HOR_order <= 0) {
                            std::cout << "Beta HOR order value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 9 :

                        //std::cout << "Min HOR order: " << optarg << std::endl << std::endl;
                        parsed_args.min_HOR_order = std::stoi(optarg);

                        if (parsed_args.min_HOR_order <= 0) {
                            std::cout << "Min HOR order value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 10 :

                        //std::cout << "Max HOR order: " << optarg << std::endl << std::endl;
                        parsed_args.max_HOR_order = std::stoi(optarg);

                        break;

                    case 11 :

                        //std::cout << "Substitution rate: " << optarg << std::endl << std::endl;
                        parsed_args.substitution_rate = std::stod(optarg);

                        if (parsed_args.substitution_rate <= 0) {
                            std::cout << "Substitution rate value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 12 :

                        //std::cout << "Transition/transversion ratio : " << optarg << std::endl << std::endl;
                        parsed_args.transition_transversion_ratio = std::stod(optarg);

                        if (parsed_args.transition_transversion_ratio <= 0) {
                            std::cout << "Transition/transversion ratio value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 13 :

                        //std::cout << "Nb orders tested per monomer: " << optarg << std::endl << std::endl;
                        parsed_args.nb_orders_tested = std::stoi(optarg);

                        break;

                    case 14 :

                        //std::cout << "Nb similarities calculated per order for each monomer: " << optarg << std::endl << std::endl;
                        parsed_args.nb_similarities_calculated_per_order = std::stoi(optarg);

                        break;

                    case 15 :

                        //std::cout << "Seed: " << optarg << std::endl << std::endl;
                        parsed_args.seed = std::stoi(optarg);

                        break;

                    case 16 :

                        //std::cout << "Output option : " << optarg << std::endl << std::endl;
                        parsed_args.output_option = std::stoi(optarg);

                        if (parsed_args.output_option < -1 || parsed_args.output_option > 3) {
                            std::cout << "Output option value must be -1, 0, 1, 2 or 3." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 17 :

                        //std::cout << "Monomers dataset output path: " << optarg << std::endl << std::endl;
                        dir_dataset = std::filesystem::path(optarg).parent_path();
                        if (std::filesystem::exists(dir_dataset) && std::filesystem::is_directory(dir_dataset)) {
                            if (std::filesystem::exists(optarg)) {
                                std::cout << "Pre-existing file found. It will be replaced by the newly generated output file." << std::endl << std::endl;
                            }
                            parsed_args.monomers_dataset_output_path = optarg;
                        
                        }else{
                            std::cout << "No such monomers dataset output directory." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 18 :

                        //std::cout << "Tree output path: " << optarg << std::endl << std::endl;
                        dir_tree = std::filesystem::path(optarg).parent_path();
                        if (std::filesystem::exists(dir_tree) && std::filesystem::is_directory(dir_tree)) {
                            if (std::filesystem::exists(optarg)) {
                                std::cout << "Pre-existing file found. It will be replaced by the newly generated output file." << std::endl << std::endl;
                            }
                            parsed_args.tree_output_path = optarg;
                        
                        }else{
                            std::cout << "No such tree output directory." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 19 :

                        //std::cout << "Parameters log path : " << optarg << std::endl << std::endl;
                        dir_parameters_log = std::filesystem::path(optarg).parent_path();
                        if (std::filesystem::exists(dir_parameters_log) && std::filesystem::is_directory(dir_parameters_log)) {
                            if (std::filesystem::exists(optarg)) {
                                std::cout << "Pre-existing file found. It will be replaced by the newly generated log file." << std::endl << std::endl;
                            }
                            parsed_args.monomers_dataset_output_path = optarg;
                        
                        }else{
                            std::cout << "No such parameters log directory." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 20 :

                        //std::cout << "Parameters log path : " << optarg << std::endl << std::endl;
                        dir_final_output = std::filesystem::path(optarg).parent_path();
                        if (std::filesystem::exists(dir_final_output) && std::filesystem::is_directory(dir_final_output)) {
                            parsed_args.monomers_dataset_output_path = optarg;
                        
                        }else{
                            std::cout << "No such final output directory." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    default:

                        exit(1);

                }

                break;

            case '?':
            case 'h':

                std::cout << std::endl;
                std::cout << usage.c_str();
                
                exit(1);

            default:

                exit(1);
        }

    }

    if (parsed_args.input.empty()){
        std::cout << "Input argument is required.\n" << std::endl;
        std::cout << usage.c_str();
        exit(1);
    }

    if (parsed_args.min_amplification_size > parsed_args.max_amplification_size) {
        std::cout << "Max amplification size value must be >= min amplification size." << std::endl << std::endl;
        std::cout << usage.c_str();
        exit(1);
    }

    if (parsed_args.min_HOR_order > parsed_args.max_HOR_order) {
        std::cout << "Max HOR order value must be >= min HOR order." << std::endl << std::endl;
        std::cout << usage.c_str();
        exit(1);
    }

    if (parsed_args.monomers_dataset_output_path.empty()){
        parsed_args.monomers_dataset_output_path = parsed_args.input + ".monomers_dataset_simulation_" + parsed_args.simulation_id + ".fst" ;
    }

    if ( (parsed_args.output_option == 1 || parsed_args.output_option == 3) && parsed_args.tree_output_path.empty()){
        parsed_args.tree_output_path = parsed_args.input + ".phylogenic_tree_simulation_" + parsed_args.simulation_id + ".tree" ;
    }

    if (parsed_args.parameters_log_path.empty()){
        parsed_args.parameters_log_path = parsed_args.input + ".parameters_log_" + parsed_args.simulation_id + ".log" ;
    }

    if (parsed_args.final_output_path.empty()){
        parsed_args.final_output_path = parsed_args.input + ".simulation_parameters_and_data_description.tab" ;
    }



    /**< Prints the simulation parameters to the terminal if needed. */
    if (parsed_args.verbose > 0) {

        std::cout << "Input: " << parsed_args.input << std::endl;
        std::cout << "Max size: " << parsed_args.max_size << std::endl;
        std::cout << "Simulation Id: " << parsed_args.simulation_id << std::endl;
        std::cout << "Amplification rate: " << parsed_args.amplification_rate << std::endl;

        std::cout << "Min amplification size: " << parsed_args.min_amplification_size << std::endl;
        std::cout << "Max amplification size: " << parsed_args.max_amplification_size << std::endl;
        std::cout << "Alpha amplification size: " << parsed_args.alpha_amplification_size << std::endl;
        std::cout << "Beta amplification size: " << parsed_args.beta_amplification_size << std::endl;

        std::cout << "Min HOR order: " << parsed_args.min_HOR_order << std::endl;
        std::cout << "Max HOR order: " << parsed_args.max_HOR_order << std::endl;
        std::cout << "Alpha HOR order: " << parsed_args.alpha_HOR_order << std::endl;
        std::cout << "Beta HOR order: " << parsed_args.beta_HOR_order << std::endl;

        std::cout << "Substitution rate: " << parsed_args.substitution_rate << std::endl;
        std::cout << "Transition/transversion ratio: " << parsed_args.transition_transversion_ratio << std::endl;

        std::cout << "Nb orders tested: " << parsed_args.nb_orders_tested << std::endl;
        std::cout << "Nb similarities calculated per order: " << parsed_args.nb_similarities_calculated_per_order << std::endl;

        std::cout << "Seed: " << parsed_args.seed << std::endl;

        std::cout << "Monomers dataset output path: " << parsed_args.monomers_dataset_output_path << std::endl;
        std::cout << "Tree output path: " << parsed_args.tree_output_path << std::endl;

        std::cout << "Final output path: " << parsed_args.final_output_path << std::endl;

        std::cout << "Verbosity level: " << parsed_args.verbose << std::endl << std::endl;
    }

    /**< Writes the simulation parameters to the log file chosen by the user. */
    if (parsed_args.output_option == 2 || parsed_args.output_option == 3) {

        std::ofstream parameters_log_stream(parsed_args.parameters_log_path);

        parameters_log_stream << "Input: " << parsed_args.input << std::endl;
        parameters_log_stream << "Max size: " << parsed_args.max_size << std::endl;
        parameters_log_stream << "Simulation Id: " << parsed_args.simulation_id << std::endl;
        parameters_log_stream << "Amplification rate: " << parsed_args.amplification_rate << std::endl;

        parameters_log_stream << "Min amplification size: " << parsed_args.min_amplification_size << std::endl;
        parameters_log_stream << "Max amplification size: " << parsed_args.max_amplification_size << std::endl;
        parameters_log_stream << "Alpha amplification size: " << parsed_args.alpha_amplification_size << std::endl;
        parameters_log_stream << "Beta amplification size: " << parsed_args.beta_amplification_size << std::endl;

        parameters_log_stream << "Min HOR order: " << parsed_args.min_HOR_order << std::endl;
        parameters_log_stream << "Max HOR order: " << parsed_args.max_HOR_order << std::endl;
        parameters_log_stream << "Alpha HOR order: " << parsed_args.alpha_HOR_order << std::endl;
        parameters_log_stream << "Beta HOR order: " << parsed_args.beta_HOR_order << std::endl;

        parameters_log_stream << "Substitution rate: " << parsed_args.substitution_rate << std::endl;
        parameters_log_stream << "Transition/transversion ratio: " << parsed_args.transition_transversion_ratio << std::endl;

        parameters_log_stream << "Nb orders tested: " << parsed_args.nb_orders_tested << std::endl;
        parameters_log_stream << "Nb similarities calculated per order: " << parsed_args.nb_similarities_calculated_per_order << std::endl;

        parameters_log_stream << "Seed: " << parsed_args.seed << std::endl;

        parameters_log_stream << "Monomers dataset output path: " << parsed_args.monomers_dataset_output_path << std::endl;
        parameters_log_stream << "Tree output path: " << parsed_args.tree_output_path << std::endl;

        parameters_log_stream << "Verbosity level: " << parsed_args.verbose << std::endl << std::endl;
    }


    return parsed_args;
}




/** @brief Main function
*
* Main function in charge of the overall execution of the script including the execution of the argument parsing function , the simulation and dat description functions and the output generation functions.
*
* @param argc Number of arguments provided by the user in the command line.
* @param argv List of arguments provided by the user in the command line.
*
* @return 0 if normal execution, other number if error.
*/
int main(int argc, char **argv) {

    /**< Stores the arguments for this execution of the script parsed by the get_args function. */
    Args args = get_args(argc, argv);

    bpp::Fasta fasta = bpp::Fasta();
    std::shared_ptr<const bpp::Alphabet> alpha = bpp::AlphabetTools::DNA_ALPHABET;
    bpp::Sequence ancestor_monomer = bpp::Sequence(alpha);
    std::ifstream ancestor_monomer_input_stream(args.input);
    fasta.nextSequence(ancestor_monomer_input_stream, ancestor_monomer);

    /**< Writes the simulation parameters to the final output file chosen by the user. */

    std::ofstream final_output_stream(args.final_output_path, std::ios::app);

    final_output_stream << "sim_id\t" << args.simulation_id ;

    final_output_stream << "\tmax_size\t" << args.max_size ;
    
    final_output_stream << "\tamp_rate\t" << args.amplification_rate;
    
    final_output_stream << "\tmin_amp_size\t" << args.min_amplification_size;
    final_output_stream << "\tmax_amp_size\t" << args.max_amplification_size;
    final_output_stream << "\talpha_amp_size\t" << args.alpha_amplification_size;
    final_output_stream << "\tbeta_amp_size\t" << args.beta_amplification_size;

    final_output_stream << "\tmin_HOR_order\t" << args.min_HOR_order;
    final_output_stream << "\tmax_HOR_order\t" << args.max_HOR_order;
    final_output_stream << "\talpha_HOR_order\t" << args.alpha_HOR_order;
    final_output_stream << "\tbeta_HOR_order\t" << args.beta_HOR_order;

    final_output_stream << "\tsub_rate\t" << args.substitution_rate;
    final_output_stream << "\tt/tv_ratio\t" << args.transition_transversion_ratio;

    final_output_stream << "\tnb_orders_tested\t" << args.nb_orders_tested ;
    final_output_stream << "\tnb_sim_per_order\t" << args.nb_similarities_calculated_per_order;

    final_output_stream << "\tseed\t" << args.seed << "\t";



    bpp::TreeTemplate<bpp::Node>* tree ; /**< Tree data structure supposed to contain nodes that represent monomers amplified from a common ancestor monomer */
    std::list<bpp::Node*> monomers_dataset ; /**< Doubly chained list containing smart pointers pointing to leaves from the tree structure defined just above */

    /**< Stores the Output_data structure containing the tree and the monomers dataset generated by the amplification simulation. */
    amplification_simulation(args.max_size, args.amplification_rate, args.alpha_amplification_size, args.beta_amplification_size, args.min_amplification_size, args.max_amplification_size, args.alpha_HOR_order, args.beta_HOR_order, args.min_HOR_order, args.max_HOR_order, ancestor_monomer, alpha, args.substitution_rate, args.transition_transversion_ratio, args.seed, args.verbose-1, &tree, &monomers_dataset) ;

    if (args.verbose > 0) std::cout << "Amplification simulation done." << std::endl << std::endl;
    
    /**< Creates the object allowing to export the tree to a NHX formated file. */
    bpp::Nhx nhxWriter = bpp::Nhx(false) ;

    /**< Adds the amplification id as a registred property that will be written for each node in the NHX file. */
    nhxWriter.registerProperty(bpp::Nhx::Property("amplification_id","XN",false,1));

    if (args.output_option == 1 || args.output_option == 3) {
        /**< Writes the tree to the output file chosen by the user. */
        nhxWriter.writeTree(*(tree),args.tree_output_path,true);
    }

    /**< Declares the vector variable used to store the sequences from the fasta file passed as input. */
    std::vector<std::string> list_sequences;
    
    /**< Writes the monomers dataset to the fasta output file chosen by the user. */
    std::ofstream monomers_dataset_output_stream;
    if (args.output_option != -1) monomers_dataset_output_stream.open(args.monomers_dataset_output_path);
    std::list<bpp::Node*>::iterator monomers_dataset_iterator = monomers_dataset.begin() ;
    std::for_each (monomers_dataset_iterator, std::next(monomers_dataset_iterator,monomers_dataset.size()), [&monomers_dataset, &monomers_dataset_output_stream, &list_sequences, &args](bpp::Node* m) { 
        /**< Writes the monomers dataset to the output fasta file if needed. */
        if (args.output_option != -1) monomers_dataset_output_stream << ">" << m->getName() << " " << "A_" << (dynamic_cast<bpp::BppInteger*>(m->getNodeProperty("amplification_id")))->getValue() << "\n" << *dynamic_cast<bpp::BppString*>(m->getNodeProperty("sequence")) << std::endl; 
        
        /**< Adds each sequence of the monomers dataset to a list in order to pass it to the data description function. */
        list_sequences.push_back(dynamic_cast<bpp::BppString*>(m->getNodeProperty("sequence"))->toSTL());
    });

    /**< Prints or not the monomers dataset and the NHX formated tree depending on the verbosity level. */
    if (args.verbose > 0){
        /**< Monomers dataset */
        std::cout << "Id" << "\t" << "Name"  << "\t" << "Amplification_ID" << "\t" << "Parent_name" << "\t" << "Sequence" << std::endl << std::endl;
        monomers_dataset_iterator = monomers_dataset.begin() ;
        std::for_each (monomers_dataset_iterator, std::next(monomers_dataset_iterator,monomers_dataset.size()), [&monomers_dataset](bpp::Node* m) { std::cout << m->getId() << "\t" << m->getName() << "\t" << (dynamic_cast<bpp::BppInteger*>(m->getNodeProperty("amplification_id")))->getValue() << "\t" << *(dynamic_cast<bpp::BppString*>(m->getNodeProperty("parent_name"))) << "\t" << *dynamic_cast<bpp::BppString*>(m->getNodeProperty("sequence")) << std::endl << std::endl << std::endl; });
        std::cout << std::endl << std::endl;
    
        /**< NHX formated tree */
        std::cout << nhxWriter.treeToParenthesis(*(tree)) << std::endl;

        std::cout << "Writing done." << std::endl;
    }

    /**< Generates the data used to compare the results of the simulation to the observed data. */
    std::string summary_stats = generate_summary_stats(args.nb_orders_tested, args.nb_similarities_calculated_per_order, args.seed, &list_sequences);

    final_output_stream << summary_stats << std::endl;

    return 0;
}