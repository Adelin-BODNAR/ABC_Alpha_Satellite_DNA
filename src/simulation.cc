/**
* @file simulation.cc
* @brief Monomers amplification and mutation simulation script.
* @author Adelin BODNAR
* @date 02/04/2024
*
* Script used to simulate the successive amplifications and mutations (substitutions (TODO : and/or indels)) of an ancestor monomer and its children.
*
*/

#include <algorithm>    //std::insert
#include <array>    //std::array<>
#include <boost/random.hpp> //boost::random::beta_distribution<double>
#include <Bpp/BppString.h>  //bpp::BppString
#include <Bpp/Numeric/Number.h> //bpp::BppInteger
#include <Bpp/Phyl/Io/Nhx.h>    //bpp::Nhx
#include <Bpp/Phyl/Tree/Node.h> //bpp::Node
#include <Bpp/Phyl/Tree/Tree.h> //bpp::TreeTemplate<bpp::Node>
#include <Bpp/Seq/Alphabet/AlphabetTools.h> //bpp::Alphabet, bpp::AlphabetTools
#include <Bpp/Seq/Io/Fasta.h>   //bpp::Fasta
#include <cstdlib>   // For srand()
#include <filesystem>   //std::filesystem::path, std::filesystem::exists, std::filesystem::is_directory
#include <fstream>  //std::ifstream, std::ofstream
#include <getopt.h> //getopt_long
#include <list> //std::list
#include <map>  //std::map<>
#include <memory>   //std::shared_ptr<>
#include <random>    // For std::mt19937
#include <string>   //std::string, std::stoi, std::stod
#include <time.h>   //std::time
#include <vector>   //std::vector

/** @brief Parsed arguments structure
* 
* Structure used to store the arguments provided by the user in the command line after parsing.
*/
struct Args {

    int verbose ; /**< Integer used to determine the level of verbosity for the execution of the script */

    std::string input ; /**< String containing the path provided by the user to the input fasta file with the ancestor monomer */
    int max_size ; /**< Number of monomers aimed for in the dataset at the end of the simulation */
    std::string simulation_id ; /**< String used as an identifier of an execution of the simulation script */
    double amplification_rate ; /**< Rate at which each monomer in the dataset is amplified */

    double alpha_amplification_size ; /**< Alpha parameter for the beta distribution used to draw a random value for the amplification size during each amplification event */
    double beta_amplification_size ; /**< Beta parameter for the beta distribution used to draw a random value for the amplification size during each amplification event */
    int min_amplification_size ; /**< Minimum value of the range from which a random value for the amplification size is drawn during each amplification event */
    int max_amplification_size ; /**< Maximum value of the range from which a random value for the amplification size is drawn during each amplification event */

    double alpha_HOR_order ; /**< Alpha parameter for the beta distribution used to draw a random value for the HOR order during each amplification event */
    double beta_HOR_order ; /**< Beta parameter for the beta distribution used to draw a random value for the HOR order during each amplification event */
    int min_HOR_order ; /**< Minimum value of the range from which a random value for the HOR order is drawn during each amplification event */
    int max_HOR_order ; /**< Maximum value of the range from which a random value for the HOR order is drawn during each amplification event */

    double substitution_rate ; /**< Rate at which a substitution event occurs in the sequence of a monomer. */
    double transition_transversion_ratio; /**< Double variable used to store the transition/transversion ratio involved in the initialization of the substitution matrix  (Ratio == 1 is equivalent to the Jukes-Cantor model, ratio != 1 is equivalent to the Kimura 80 model). */

    int seed; /**< Integer variable used to initialize the random number generators. */

    int output_option ; /**< Integer variable used to store the otpion chosen by the user for what outputs must be produced. (0 : Monomers dataset only, 1 : Monomers dataset and phylogenetic tree, 2 : Monomers dataset and simulation parameters, 3 : Monomers dataset, phylogenetic tree and simulation parameters) */

    std::string parameters_log_path ; /**< String containing the path to the log file containing the values for the simulation parameters chosen by the user. */

    std::string monomers_dataset_output_path ; /**< String containing the path to the output fasta file generated by the script with the monomers from the dataset retaining their spatial organization */
    std::string tree_output_path ; /**< String containing the path to the output NHX file generated by the script with the phylogenic tree retracing the amplification history of the monomers */

};


/** @brief Parsing the arguments.
*
* Function parsing the arguments provided by the user in the command line and storing them in the structure defined above.
*
* @param argc The number of arguments provided by the user in the command line.
* @param argv The list of arguments provided by the user in the command line.
*
* @return parsed_args an instance of the Args structure containing the arguments provided by the user and used as parameters for multiple parts of the simulation script
*/
Args get_args(int argc, char **argv) {

    //Initializing parsed_args and default values for some of its attributes

    Args parsed_args ;  /**< Variable used to store and return the arguments provided by the user after parsing */

    parsed_args.verbose = 0;   /**< Initializes the default verbosity level at 0 */

    parsed_args.max_size = 15000 ;          /**< Initializes the default max size for the monomers dataset at 15 000 monomers (middle ground between ~30 000 monomers for the largest human chromosome and ~5 000 for the smallest) */
    parsed_args.simulation_id = "no_id" ;   /**< Initializes the default simulation id */
    parsed_args.amplification_rate = 1.0 ;  /**< Initializes the default amplification rate at 1 amplification per monomer per time unit */

    parsed_args.alpha_amplification_size = 1.0 ;    /**< Initializes the default alpha parameter for the amplification size beta distribution at 1 to mimic an uniform distribution with the default beta parameter */
    parsed_args.beta_amplification_size = 1.0 ;     /**< Initializes the default beta parameter for the amplification size beta distribution at 1 to mimic an uniform distribution with the default alpha parameter */
    parsed_args.min_amplification_size = 1 ;        /**< Initializes the default minimum amplification size to 1 to perform at the very least a duplication for each amplification event */
    parsed_args.max_amplification_size = 10000 ;    /**< Initializes the default maximum amplification size */ //TODO : Find the right value and a justification for it.

    parsed_args.alpha_HOR_order = 1.0 ;     /**< Initializes the default alpha parameter for the HOR order beta distribution at 1 to mimic an uniform distribution with the default beta parameter */
    parsed_args.beta_HOR_order = 1.0 ;      /**< Initializes the default beta parameter for the HOR order beta distribution at 1 to mimic an uniform distribution with the default alpha parameter */
    parsed_args.min_HOR_order = 1 ;         /**< Initializes the default minimum HOR order to 1 to also mimic the amplifications resulting to a monomeric organization (layer of monomers amplified for one origin monomer) */
    parsed_args.max_HOR_order = 50 ;        /**< Initializes the default maximum HOR order to 50 monomers since it is not much above 34 monomers the maximum observed yet in humans */

    parsed_args.substitution_rate = 1 ;  /**< Initializes the default substitution rate at 1 substitution per time unit */
    parsed_args.transition_transversion_ratio = 1 ; /**< Initializes the default transition/transversion ratio at 1 to mimic the Jukes-Cantor model. */

    parsed_args.seed = std::time(0) ; /**< Initializes the default seed at the current time in seconds. */

    parsed_args.output_option = 0 ; /**< Initializes the default output option at 0 to only produce the monomers dataset. */

    std::filesystem::path dir_dataset ; /**< Declares the path variable used to store the path to the directory that will contain the monomers dataset output file. */
    std::filesystem::path dir_tree ;    /**< Declares the path variable used to store the path to the directory that will contain the phylogenetic tree output file. */

    std::filesystem::path dir_parameters_log ;  /**< Declares the path variable used to store the path to the directory that will contain the simulation parameters log file. */


    /**< String containing the help message printed when the -h , --help or a wrong option are provided ny the user */
    const std::string usage = "Usage: \n"
                            "\t./simulation [-h] -i INPUT [-s MAX_SIZE] [--id SIMULATION_ID] [--amplification_rate AMPLIFICATION_RATE] \n"
                            "\t[--alpha_amplification_size ALPHA_AMPLIFICATION_SIZE] [--beta_amplification_size BETA_AMPLIFICATION_SIZE]\n"
                            "\t[--min_amplification_size MIN_AMPLIFICATION_SIZE] [--max_amplification_size MAX_AMPLIFICATION_SIZE]\n"
                            "\t[--alpha_HOR_order ALPHA_HOR_ORDER] [--beta_HOR_order BETA_HOR_ORDER] [--min_HOR_order MIN_HOR_ORDER]\n"
                            "\t[--max_HOR_order MAX_HOR_ORDER] [--substitution_rate SUBSTITUTION_RATE] [--transition_transversion_ratio TRANSITION_TRANSVERSION_RATIO] \n"
                            "\t[--seed SEED] [--output_option OUTPUT_OPTION] [--parameters_log_path PARAMETERS_LOG_PATH] \n"
                            "\t[--monomers_dataset_output_path MONOMERS_DATASET_OUTPUT_PATH] [--tree_output_path TREE_OUTPUT_PATH] [-v | --verbose | --no-verbose]\n\n"

                            "\toptions:\n\n"

                            "\t-h, --help \n\t\tOption showing this help message and exiting\n\n"

                            "\t-i INPUT, --input INPUT\n"
                            "\t\tArgument defining the input fasta file containing the \n"
                            "\t\tancestor monomer used to perform the simulation \n\n"

                            "\t-s MAX_SIZE, --max_size MAX_SIZE \n"
                            "\t\tArgument defining the max size of the monomers dataset \n"
                            "\t\tbefore the simulation stops \n\n"

                            "\t--id SIMULATION_ID, --simulation_id SIMULATION_ID \n"
                            "\t\tArgument defining the ID used to identify the current \n"
                            "\t\trun of the simulation \n\n"

                            "\t--amplification_rate AMPLIFICATION_RATE \n"
                            "\t\tArgument defining the rate at which monomers \n"
                            "\t\tare amplified in the simulation \n\n"

                            "\t--alpha_amplification_size ALPHA_AMPLIFICATION_SIZE \n"
                            "\t\tArgument defining the alpha of the law allowing to \n"
                            "\t\tdraw randomly the number of new copies each monomer \n"
                            "\t\tinvolved gets during an amplification event \n\n"

                            "\t--beta_amplification_size BETA_AMPLIFICATION_SIZE \n"
                            "\t\tArgument defining the beta of the law allowing to draw \n"
                            "\t\trandomly the number of new copies each monomer \n"
                            "\t\tinvolved gets during an amplification event \n\n"

                            "\t--min_amplification_size MIN_AMPLIFICATION_SIZE \n"
                            "\t\tArgument defining the minimum of the values from which \n"
                            "\t\twe have to draw randomly the number of new copies each \n"
                            "\t\tmonomer involved gets during an amplification event \n\n"

                            "\t--max_amplification_size MAX_AMPLIFICATION_SIZE \n"
                            "\t\tArgument defining the maximum of the values from which \n"
                            "\t\twe have to draw randomly the number of new copies each \n"
                            "\t\tmonomer involved gets during an amplification event \n\n"

                            "\t--alpha_HOR_order ALPHA_HOR_ORDER \n"
                            "\t\tArgument defining the alpha for the law allowing to \n"
                            "\t\tdraw the number of adjacent monomers involved in the \n"
                            "\t\tan amplification event \n\n"

                            "\t--beta_HOR_order BETA_HOR_ORDER \n"
                            "\t\tArgument defining the beta for the law allowing to \n"
                            "\t\tdraw the number of adjacent monomers involved in the \n"
                            "\t\tan amplification event \n\n"

                            "\t--min_HOR_order MIN_HOR_ORDER \n"
                            "\t\tArgument defining the minimum of the values from which \n"
                            "\t\twe have to draw the number of adjacent monomers \n"
                            "\t\tinvolved in the an amplification event \n\n"

                            "\t--max_HOR_order MAX_HOR_ORDER \n"
                            "\t\tArgument defining the maximum of the values from which \n"
                            "\t\twe have to draw the number of adjacent monomers \n"
                            "\t\tinvolved in the an amplification event \n\n"

                            "\t--substitution_rate SUBSTITUTION_RATE \n"
                            "\t\tArgument defining the rate at which nucleotides are substituted \n"
                            "\t\tin the sequence of a monomer during the simulation \n\n"

                            "\t--transition_transversion_ratio TRANSITION_TRANSVERSION_RATIO \n"
                            "\t\tArgument defining the transition/transversion ratio used to initialize the matrix \n"
                            "\t\tnecessary to perform substitutions in the sequence of a monomer during the simulation \n"
                            "\t\t(== 1 is equivalent to the Jukes-Cantor model, != 1 is equivalent to the Kimura 80 model) \n\n"

                            "\t--seed SEED \n"
                            "\t\tArgument defining the seed used to initialize the random \n"
                            "\t\tnumber generator \n\n"

                            "\t--output_option OUTPUT_OPTION \n"
                            "\t\tArgument defining the output option given by the user and \n"
                            "\t\tused to determine what outputs must be produced \n"
                            "\t\t(0 : Monomers dataset only, 1 : Monomers dataset and phylogenetic tree, \n"
                            "\t\t2 : Monomers dataset and simulation parameters, 3 : Monomers dataset, phylogenetic tree and simulation parameters) \n\n"

                            "\t--parameters_log_path PARAMETERS_LOG_PATH \n"
                            "\t\tArgument defining the path to the log file containing \n"
                            "\t\tthe values chosen for the simulation parameters \n\n"

                            "\t--monomers_dataset_output_path MONOMERS_DATASET_OUTPUT_PATH \n"
                            "\t\tArgument defining the path to the monomers dataset \n"
                            "\t\toutput file \n\n"

                            "\t--tree_output_path TREE_OUTPUT_PATH \n"
                            "\t\tArgument defining the path to the phylogenic tree \n"
                            "\t\toutput file \n\n"

                            "\t-v, --verbose, --no-verbose \n"
                            "\t\tOptions allowing to print or not the script execution \n"
                            "\t\tsupervision prints (tree and list after each amplification event) \n\n" ;


    /** @brief Long options defining structure
    *
    * Structure used by the function getopt_long to define, parse and link to their short versions the long options for the simulation script.
    */
    const struct option long_options[] =
        {
          // These options don’t set a flag. We distinguish them by their indices. 

          {"id", required_argument, 0, 0},
          {"simulation_id", required_argument, 0, 0},

          {"amplification_rate", required_argument, 0, 0},

          {"alpha_amplification_size", required_argument, 0, 0},
          {"beta_amplification_size", required_argument, 0, 0},
          {"min_amplification_size", required_argument, 0, 0},
          {"max_amplification_size", required_argument, 0, 0},

          {"alpha_HOR_order", required_argument, 0, 0},
          {"beta_HOR_order", required_argument, 0, 0},
          {"min_HOR_order", required_argument, 0, 0},
          {"max_HOR_order", required_argument, 0, 0},

          {"substitution_rate", required_argument, 0, 0},
          {"transition_transversion_ratio", required_argument, 0, 0},

          {"seed", required_argument, 0, 0},

          {"output_option", required_argument, 0, 0},

          {"parameters_log_path", required_argument, 0, 0},

          {"monomers_dataset_output_path", required_argument, 0, 0},
          {"tree_output_path", required_argument, 0, 0},

          //  These options set flags. 

          {"help", no_argument, 0, 'h'},

          {"input", required_argument, 0, 'i'},
          {"max_size", required_argument, 0, 's'},

          {"verbose", no_argument, 0, 'v'},

          {0, 0, 0, 0}
        };

    // getopt_long stores the option index here.
    int option_index;

    int c;

    while ((c = getopt_long (argc, argv, "hi:s:v", long_options, &option_index)) != -1) {

        switch (c)
        {
            case 'i':

                //std::cout << "Input: " << optarg << std::endl;
                if (std::filesystem::exists(optarg)) {
                    //std::cout << "Input file found.\n" << std::endl;
                    parsed_args.input = optarg;
                }else{
                    std::cout << "No such input file.\n" << std::endl;
                    std::cout << usage.c_str();
                    exit(1);
                }

                break;

            case 's':
                
                //std::cout << "Max size: " << optarg << std::endl << std::endl;
                if (std::stoi(optarg) > 0) {
                    parsed_args.max_size = std::stoi(optarg) ;
                }else{
                    std::cout << "Max size value must be > 0." << std::endl << std::endl;
                    std::cout << usage.c_str();
                    exit(1);
                }

                break;

            case 'v':
                
                parsed_args.verbose ++ ;
               
                break;

            case 0 :
                
                switch (option_index){

                    case 0 :
                    case 1 :

                        //std::cout << "Simulation Id: " << optarg << std::endl << std::endl;
                        parsed_args.simulation_id = optarg;

                        break ;
                    
                    case 2 :

                        //std::cout << "Amplification rate: " << optarg << std::endl << std::endl;
                        parsed_args.amplification_rate = std::stod(optarg);

                        if (parsed_args.amplification_rate <= 0) {
                            std::cout << "Amplification rate value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 3 :

                        //std::cout << "Alpha amplification size: " << optarg << std::endl << std::endl;
                        parsed_args.alpha_amplification_size = std::stod(optarg);

                        if (parsed_args.alpha_amplification_size <= 0) {
                            std::cout << "Alpha amplification size value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 4 :

                        //std::cout << "Beta amplification size: " << optarg << std::endl << std::endl;
                        parsed_args.beta_amplification_size = std::stod(optarg);

                        if (parsed_args.beta_amplification_size <= 0) {
                            std::cout << "Beta amplification size value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 5 :

                        //std::cout << "Min amplification size: " << optarg << std::endl << std::endl;
                        parsed_args.min_amplification_size = std::stoi(optarg);

                        if (parsed_args.min_amplification_size <= 0) {
                            std::cout << "Alpha amplification size value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 6 :

                        //std::cout << "Max amplification size: " << optarg << std::endl << std::endl;
                        parsed_args.max_amplification_size = std::stoi(optarg);

                        break;

                    case 7 :

                        //std::cout << "Alpha HOR order: " << optarg << std::endl << std::endl;
                        parsed_args.alpha_HOR_order = std::stod(optarg);

                        if (parsed_args.alpha_HOR_order <= 0) {
                            std::cout << "Alpha HOR order value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 8 :

                        //std::cout << "Beta HOR order: " << optarg << std::endl << std::endl;
                        parsed_args.beta_HOR_order = std::stod(optarg);

                        if (parsed_args.beta_HOR_order <= 0) {
                            std::cout << "Beta HOR order value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 9 :

                        //std::cout << "Min HOR order: " << optarg << std::endl << std::endl;
                        parsed_args.min_HOR_order = std::stoi(optarg);

                        if (parsed_args.min_HOR_order <= 0) {
                            std::cout << "Min HOR order value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 10 :

                        //std::cout << "Max HOR order: " << optarg << std::endl << std::endl;
                        parsed_args.max_HOR_order = std::stoi(optarg);

                        break;

                    case 11 :

                        //std::cout << "Substitution rate: " << optarg << std::endl << std::endl;
                        parsed_args.substitution_rate = std::stod(optarg);

                        if (parsed_args.substitution_rate <= 0) {
                            std::cout << "Substitution rate value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 12 :

                        //std::cout << "Transition/transversion ratio : " << optarg << std::endl << std::endl;
                        parsed_args.transition_transversion_ratio = std::stod(optarg);

                        if (parsed_args.transition_transversion_ratio <= 0) {
                            std::cout << "Transition/transversion ratio value must be > 0." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 13 :

                        //std::cout << "Seed: " << optarg << std::endl << std::endl;
                        parsed_args.seed = std::stoi(optarg);

                        break;

                    case 14 :

                        //std::cout << "Output option : " << optarg << std::endl << std::endl;
                        parsed_args.output_option = std::stoi(optarg);

                        if (parsed_args.output_option < 0 || parsed_args.output_option > 3) {
                            std::cout << "Output option value must be 0, 1, 2 or 3." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 15 :

                        //std::cout << "Parameters log path : " << optarg << std::endl << std::endl;
                        dir_parameters_log = std::filesystem::path(optarg).parent_path();
                        if (std::filesystem::exists(dir_parameters_log) && std::filesystem::is_directory(dir_parameters_log)) {
                            if (std::filesystem::exists(optarg)) {
                                std::cout << "Pre-existing file found. It will be replaced by the newly generated log file." << std::endl << std::endl;
                            }
                            parsed_args.monomers_dataset_output_path = optarg;
                        
                        }else{
                            std::cout << "No such parameters log directory." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 16 :

                        //std::cout << "Monomers dataset output path: " << optarg << std::endl << std::endl;
                        dir_dataset = std::filesystem::path(optarg).parent_path();
                        if (std::filesystem::exists(dir_dataset) && std::filesystem::is_directory(dir_dataset)) {
                            if (std::filesystem::exists(optarg)) {
                                std::cout << "Pre-existing file found. It will be replaced by the newly generated output file." << std::endl << std::endl;
                            }
                            parsed_args.monomers_dataset_output_path = optarg;
                        
                        }else{
                            std::cout << "No such monomers dataset output directory." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    case 17 :

                        //std::cout << "Tree output path: " << optarg << std::endl << std::endl;
                        dir_tree = std::filesystem::path(optarg).parent_path();
                        if (std::filesystem::exists(dir_tree) && std::filesystem::is_directory(dir_tree)) {
                            if (std::filesystem::exists(optarg)) {
                                std::cout << "Pre-existing file found. It will be replaced by the newly generated output file." << std::endl << std::endl;
                            }
                            parsed_args.tree_output_path = optarg;
                        
                        }else{
                            std::cout << "No such tree output directory." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    default:

                        exit(1);

                }

                break;

            case '?':
            case 'h':

                std::cout << std::endl;
                std::cout << usage.c_str();
                
                exit(1);

            default:

                exit(1);
        }

    }

    if (parsed_args.input.empty()){
        std::cout << "Input argument is required.\n" << std::endl;
        std::cout << usage.c_str();
        exit(1);
    }

    if (parsed_args.min_amplification_size > parsed_args.max_amplification_size) {
        std::cout << "Max amplification size value must be >= min amplification size." << std::endl << std::endl;
        std::cout << usage.c_str();
        exit(1);
    }

    if (parsed_args.min_HOR_order > parsed_args.max_HOR_order) {
        std::cout << "Max HOR order value must be >= min HOR order." << std::endl << std::endl;
        std::cout << usage.c_str();
        exit(1);
    }

    if (parsed_args.monomers_dataset_output_path.empty()){
        parsed_args.monomers_dataset_output_path = parsed_args.input + ".monomers_dataset_simulation_" + parsed_args.simulation_id + ".fst" ;
    }

    if ( (parsed_args.output_option == 1 || parsed_args.output_option == 3) && parsed_args.tree_output_path.empty()){
        parsed_args.tree_output_path = parsed_args.input + ".phylogenic_tree_simulation_" + parsed_args.simulation_id + ".tree" ;
    }

    if (parsed_args.parameters_log_path.empty()){
        parsed_args.parameters_log_path = parsed_args.input + ".parameters_log_" + parsed_args.simulation_id + ".log" ;
    }



    /**< Prints the simulation parameters to the terminal if needed. */
    if (parsed_args.verbose > 0) {

        std::cout << "Input: " << parsed_args.input << std::endl;
        std::cout << "Max size: " << parsed_args.max_size << std::endl;
        std::cout << "Simulation Id: " << parsed_args.simulation_id << std::endl;
        std::cout << "Amplification rate: " << parsed_args.amplification_rate << std::endl;

        std::cout << "Min amplification size: " << parsed_args.min_amplification_size << std::endl;
        std::cout << "Max amplification size: " << parsed_args.max_amplification_size << std::endl;
        std::cout << "Alpha amplification size: " << parsed_args.alpha_amplification_size << std::endl;
        std::cout << "Beta amplification size: " << parsed_args.beta_amplification_size << std::endl;

        std::cout << "Min HOR order: " << parsed_args.min_HOR_order << std::endl;
        std::cout << "Max HOR order: " << parsed_args.max_HOR_order << std::endl;
        std::cout << "Alpha HOR order: " << parsed_args.alpha_HOR_order << std::endl;
        std::cout << "Beta HOR order: " << parsed_args.beta_HOR_order << std::endl;

        std::cout << "Substitution rate: " << parsed_args.substitution_rate << std::endl;
        std::cout << "Transition/transversion ratio: " << parsed_args.transition_transversion_ratio << std::endl;

        std::cout << "Seed: " << parsed_args.seed << std::endl;

        std::cout << "Monomers dataset output path: " << parsed_args.monomers_dataset_output_path << std::endl;
        std::cout << "Tree output path: " << parsed_args.tree_output_path << std::endl;

        std::cout << "Verbosity level: " << parsed_args.verbose << std::endl << std::endl;
    }

    /**< Writes the simulation parameters to the log file chosen by the user. */
    if (parsed_args.output_option == 2 || parsed_args.output_option == 3) {

        std::ofstream parameters_log_stream(parsed_args.parameters_log_path);

        parameters_log_stream << "Input: " << parsed_args.input << std::endl;
        parameters_log_stream << "Max size: " << parsed_args.max_size << std::endl;
        parameters_log_stream << "Simulation Id: " << parsed_args.simulation_id << std::endl;
        parameters_log_stream << "Amplification rate: " << parsed_args.amplification_rate << std::endl;

        parameters_log_stream << "Min amplification size: " << parsed_args.min_amplification_size << std::endl;
        parameters_log_stream << "Max amplification size: " << parsed_args.max_amplification_size << std::endl;
        parameters_log_stream << "Alpha amplification size: " << parsed_args.alpha_amplification_size << std::endl;
        parameters_log_stream << "Beta amplification size: " << parsed_args.beta_amplification_size << std::endl;

        parameters_log_stream << "Min HOR order: " << parsed_args.min_HOR_order << std::endl;
        parameters_log_stream << "Max HOR order: " << parsed_args.max_HOR_order << std::endl;
        parameters_log_stream << "Alpha HOR order: " << parsed_args.alpha_HOR_order << std::endl;
        parameters_log_stream << "Beta HOR order: " << parsed_args.beta_HOR_order << std::endl;

        parameters_log_stream << "Substitution rate: " << parsed_args.substitution_rate << std::endl;
        parameters_log_stream << "Transition/transversion ratio: " << parsed_args.transition_transversion_ratio << std::endl;

        parameters_log_stream << "Seed: " << parsed_args.seed << std::endl;

        parameters_log_stream << "Monomers dataset output path: " << parsed_args.monomers_dataset_output_path << std::endl;
        parameters_log_stream << "Tree output path: " << parsed_args.tree_output_path << std::endl;

        parameters_log_stream << "Verbosity level: " << parsed_args.verbose << std::endl << std::endl;
    }


    return parsed_args;
}



/** @brief Simulation outputs structure
* 
* Structure used to store the outputs generated by the amplification simulation function and used by the mutation simulation function.
*/
struct Output_data {

    bpp::TreeTemplate<bpp::Node>* tree ; /**< Tree data structure supposed to contain nodes that represent monomers amplified from a common ancestor monomer */
    std::list<bpp::Node*> monomers_dataset ; /**< Doubly chained list containing smart pointers pointing to leaves from the tree structure defined just above */

} ;


/** @brief Amplification simulation.
*
* Function simulating amplifications from an ancestor monomer and storing the generated tree and dataset in the structure defined above.
*
* @param max_size Integer containing the number of monomers the simulation aims for in the dataset.
* @param amplification_rate Double countaining the number of amplifications performed per monomer per time unit.
* @param alpha_amplification_size Double containing the alpha parameter for the law used to draw a random amplification size value at each amplification event.
* @param beta_amplification_size Double containing the beta parameter for the law used to draw a random amplification size value at each amplification event.
* @param min_amplification_size Integer containing the minimum for the range from which a random amplification size value is drawn at each amplification event.
* @param max_amplification_size Integer containing the maximum for the range from which a random amplification size value is drawn at each amplification event.
* @param alpha_HOR_order Double containing the alpha parameter for the law used to draw a random HOR order value at each amplification event.
* @param beta_HOR_order Double containing the beta parameter for the law used to draw a random HOR order value at each amplification event.
* @param min_HOR_order Integer containing the minimum for the range from which a random HOR order value is drawn at each amplification event.
* @param max_HOR_order Integer containing the maximum for the range from which a random HOR order value is drawn at each amplification event.
* @param verbose Integer containing the level of verbosity chosen for the execution of this function.
* @param ancestor_monomer Sequence object containing the sequence and its infos stored in the input fasta file specified by the user.
* @param alpha Object specifying the symbols allowed in the Sequence objects.
*
* @return outputs an instance of the Output_data structure containing the tree from the Bio++ library and doubly chained list structure from the standard library representing the monomers dataset generated by the function and used later in the simulation script.
*/
Output_data amplification_simulation (int max_size, double amplification_rate, double alpha_amplification_size, double beta_amplification_size, int min_amplification_size, int max_amplification_size, double alpha_HOR_order, double beta_HOR_order, int min_HOR_order, int max_HOR_order, bpp::Sequence ancestor_monomer, std::shared_ptr<const bpp::Alphabet> alpha, double substitution_rate, double transition_transversion_ratio, int seed, int verbose ) {

    /**< Instantiates the structure used to store and return the outputs of the function */
    Output_data outputs ;

    /**< Creates the root for the tree created afterwards and the shared pointer pointing to the said root node.*/
    bpp::Node* root_ptr = new bpp::Node(0,"monomer_0");

    /**< Initializes the branch lenght between this node and its father. */
    root_ptr->setDistanceToFather(0);

    /**< Adds the amplification Id to the node as an extra property. */
    root_ptr->setNodeProperty("amplification_id", bpp::BppInteger(0));
    /**< Adds the parent name to the node as an extra property. */
    root_ptr->setNodeProperty("parent_name", bpp::BppString("tree_root"));
    /**< Adds the node to the node as an extra property. */
    root_ptr->setNodeProperty("sequence", bpp::BppString(ancestor_monomer.toString()));

    /**< Creates the tree with the root defined above. */
    outputs.tree = new bpp::TreeTemplate<bpp::Node>(root_ptr);

    /**< Creates another shared pointer pointing to the root and the doubly chained list storing it and representing the monomers dataset. */
    outputs.monomers_dataset = {root_ptr};

    /**< Iterator used to go through the doubly chained list used as the monomers dataset when needed. */
    std::list<bpp::Node*>::iterator monomers_dataset_iterator ;
    /**< Iterator used to go store the position at which the new monomers must be inserted in the monomers dataset. */
    std::list<bpp::Node*>::iterator insert_position_iterator ;

    /**< Initializes the variables used to give IDs to the new monomers and each amplification event. */
    int monomers_counter = 1 ;
    int amplification_id_counter = 0 ;
    int node_ids_counter = 0 ;

    /**< Initializes the variable used to store the HOR order of each amplification event during the simulation. */
    int HOR_order;
    /**< Initializes the variable used to store the amplification size of each amplification event during the simulation. */
    int amplification_size;
    /**< Initializes the variable used to store the index of the first monomer involved in each amplification event during the simulation. */
    int index_head_monomers_to_amplify ;
    /**< Initializes the list used to store the identifiers of the monomers involved in each amplification event during the simulation. */
    std::vector<bpp::Node*> monomers_to_amplify ;
    /**< Initializes the variable used to store the identifier of a new monomer each time one is created for each amplification event during the simulation. */
    bpp::Node* new_monomer;
    /**< Initializes the variable used to store the index in the monomers dataset where a monomer is inserted for each amplification event during the simulation. */
    int position_new_monomer ;

    /**< Initializes srand using the seed provided by the user. */
    srand(seed);
    /**< Initializes a mersenne twister type random number generator seeded by a number from the srand seeded by the user. */
    std::mt19937 random_generator(rand());

    /**< Initializes a uniform distribution used to draw random indexes during the simulation. */
    std::uniform_real_distribution<double> uniform_distrib = std::uniform_real_distribution<double>(0,1);
    /**< Initializes a beta distribution used to draw random HOR orders during the simulation. */
    boost::random::beta_distribution<double> beta_distrib_HOR_order = boost::random::beta_distribution<double>(alpha_HOR_order, beta_HOR_order);
    /**< Initializes a beta distribution used to draw random amplification sizes during the simulation. */
    boost::random::beta_distribution<double> beta_distrib_amplification_size = boost::random::beta_distribution<double>(alpha_amplification_size, beta_amplification_size);

    /**< Initializes a vector containing characters in a specific order representing nucleotides. */
    std::vector<char> nucleotides = {'A', 'C', 'G', 'T'};

    /**< Initializes a map containing an array for each nucleotide that can be encountered in a monomer sequence. Each array contains an int allowing to inintialize a discrete distribution. */
    std::map<char,std::array<int,4>> substitution_model_probs = {   {'A', { 0,  100,    int(100*transition_transversion_ratio), 100     } }, 
                                                                    {'C', { 100,    0,  100,    int(100*transition_transversion_ratio)  } }, 
                                                                    {'G', { int(100*transition_transversion_ratio), 100,    0,  100     } }, 
                                                                    {'T', { 100,    int(100*transition_transversion_ratio), 100,    0   } }
                                                                };

    /**< Initializes a map containing a discrete distribution for each nucleotide mentionned previously allowing to draw a random index corresponding to a nucleotide in the previously mentionned nucleotide vector. */
    std::map<char,std::discrete_distribution<int>> substitution_model_distribs =    {   {'A', std::discrete_distribution<int> (substitution_model_probs['A'].begin(), substitution_model_probs['A'].end()) }, 
                                                                                        {'C', std::discrete_distribution<int> (substitution_model_probs['C'].begin(), substitution_model_probs['C'].end()) }, 
                                                                                        {'G', std::discrete_distribution<int> (substitution_model_probs['G'].begin(), substitution_model_probs['G'].end()) }, 
                                                                                        {'T', std::discrete_distribution<int> (substitution_model_probs['T'].begin(), substitution_model_probs['T'].end()) }
                                                                                    };

    //Prints the probabilities for the four discrete distributions if necessary
    if (verbose >= 2) {

        std::cout << std::endl << "A\tC\tG\tT" << std::endl ;
        std::cout << (substitution_model_distribs['A']).probabilities()[0] << "\t" << (substitution_model_distribs['A']).probabilities()[1] << "\t" << (substitution_model_distribs['A']).probabilities()[2] << "\t" << (substitution_model_distribs['A']).probabilities()[3] << std::endl;
        std::cout << (substitution_model_distribs['C']).probabilities()[0] << "\t" << (substitution_model_distribs['C']).probabilities()[1] << "\t" << (substitution_model_distribs['C']).probabilities()[2] << "\t" << (substitution_model_distribs['C']).probabilities()[3] << std::endl;
        std::cout << (substitution_model_distribs['G']).probabilities()[0] << "\t" << (substitution_model_distribs['G']).probabilities()[1] << "\t" << (substitution_model_distribs['G']).probabilities()[2] << "\t" << (substitution_model_distribs['G']).probabilities()[3] << std::endl;
        std::cout << (substitution_model_distribs['T']).probabilities()[0] << "\t" << (substitution_model_distribs['T']).probabilities()[1] << "\t" << (substitution_model_distribs['T']).probabilities()[2] << "\t" << (substitution_model_distribs['T']).probabilities()[3] << std::endl << std::endl;
    }


    /**< Initializes the variable used to store the time necessary to perform all of the amplification events performed on the monomers until that point. */
    double amplification_time_passed = 0 ;

    /**< Initializes the variable used to store the time necessary to perform all of the substitution events performed on the sequences of one monomer at a time until that point. */
    double mutation_time_passed = 0 ;

    //TODO : Remove once bechmarking done
    //std::clock_t start, end;
    //double time_create, time_replace, time_insert;


    /**< Loops until the monomers dataset reached the aimed size */
    while(outputs.monomers_dataset.size() < max_size) {

        //TODO : Remove once bechmarking done
        //start = std::clock();

        /**< Increments the variable used to store the amplification id to indicate a new amplification event is simulated. */
        amplification_id_counter ++ ;

        /**< Draws random HOR order. */
        HOR_order = std::min(min_HOR_order + int( beta_distrib_HOR_order(random_generator) * (max_HOR_order - min_HOR_order + 1)), int(outputs.monomers_dataset.size())) ;
        /**< Draws random amplification size. */
        amplification_size = std::min(min_amplification_size + int( beta_distrib_amplification_size(random_generator) * (max_amplification_size - min_amplification_size + 1)), int((max_size - outputs.monomers_dataset.size())/HOR_order)+1 ) ;



        /**< Draws random index of monomer from the current monomers dataset. */
        index_head_monomers_to_amplify = int(uniform_distrib(random_generator) * (outputs.monomers_dataset.size()-HOR_order+1));

        /**< Initializes the list of monomers that will that will be involved in the amplification event. */
        monomers_to_amplify.clear() ;
        monomers_dataset_iterator = outputs.monomers_dataset.begin() ;
        advance(monomers_dataset_iterator,index_head_monomers_to_amplify);
        std::for_each (monomers_dataset_iterator, std::next(monomers_dataset_iterator,HOR_order), [&monomers_to_amplify](bpp::Node* m) { monomers_to_amplify.push_back(m); });

        /**< Draws randomly the index in the monomers dataset where the new monomers must be inserted. */
        position_new_monomer = int(uniform_distrib(random_generator) * (outputs.monomers_dataset.size()+2)) ; //TODO : Maybe choose with a beta distribution for instance instead of uniform

        insert_position_iterator = outputs.monomers_dataset.begin() ;
        advance(insert_position_iterator,position_new_monomer);

        /**< Loops to create all the monomers needed to be amplified depending on the random monomer chosen and the size of HOR. */
        for (int amplification_counter = 0; amplification_counter < amplification_size +1; amplification_counter++){

            /**< Loops through the monomers that need to be amplified to amplify them in the order of the HOR. */
            for (int HOR_counter = 0; HOR_counter < monomers_to_amplify.size(); HOR_counter++){


                //std::cout << "Nb substitutions : " << nb_substitutions << std::endl;

                /**< Creates the new copy of the currently amplified monomer and adds it to the tree (if the monomer is the replacement of the origin monomer it keeps the same name). */
                new_monomer = new bpp::Node(++node_ids_counter, (amplification_counter > 0 ? "monomer_" + std::to_string(monomers_counter) : (monomers_to_amplify[HOR_counter])->getName())) ;

                monomers_to_amplify[HOR_counter]->addSon(new_monomer) ; 
                new_monomer->setDistanceToFather(0);
                new_monomer->setNodeProperty("sequence", *(new_monomer->getFather()->getNodeProperty("sequence")));


                //TODO : Remove once bechmarking done
                //end = std::clock();
                //time_create = time_create + (((double) (end - start)) / CLOCKS_PER_SEC);
                //start = std::clock();

                /**< Replaces the origin monomers of the amplification with their replacements in the monomers dataset. */
                if (amplification_counter == 0){

                    new_monomer->setNodeProperty("amplification_id", *(new_monomer->getFather()->getNodeProperty("amplification_id"))); 
                    new_monomer->setNodeProperty("parent_name", *(new_monomer->getFather()->getNodeProperty("parent_name")));
                    *monomers_dataset_iterator = new_monomer ;
                    monomers_dataset_iterator++;

                    //TODO : Remove once bechmarking done
                    //end = std::clock();
                    //time_replace = time_replace + (((double) (end - start)) / CLOCKS_PER_SEC);

                /**< Inserts the new monomer in the monomers dataset before the position specified by insert_position_iterator. */
                }else{

                    new_monomer->setNodeProperty("amplification_id", bpp::BppInteger(amplification_id_counter)); 
                    new_monomer->setNodeProperty("parent_name", bpp::BppString(new_monomer->getFather()->getName()));
                    outputs.monomers_dataset.insert(insert_position_iterator,new_monomer); 
                    monomers_counter++;

                    //TODO : Remove once bechmarking done
                    //end = std::clock();
                    //time_insert = time_insert + (((double) (end - start)) / CLOCKS_PER_SEC);

                }

            }


        }

        /**< Calculates the time before the next amplification depending of the probability to get an amplification event and adds it to all branches of the leaves (monomers_dataset). */
        double time_amplification_event = std::exponential_distribution<>(amplification_rate * outputs.monomers_dataset.size())(random_generator);
        
        monomers_dataset_iterator = outputs.monomers_dataset.begin() ;
        std:for_each (monomers_dataset_iterator, std::next(monomers_dataset_iterator,outputs.monomers_dataset.size()), [time_amplification_event, &outputs](bpp::Node* m) {m->setDistanceToFather(time_amplification_event + m->getDistanceToFather());});

        amplification_time_passed = amplification_time_passed + time_amplification_event;

        std::exponential_distribution<> mutation_distrib = std::exponential_distribution<>(substitution_rate * outputs.monomers_dataset.size() * ancestor_monomer.toString().size());
        double time_mutation_event = mutation_distrib(random_generator);

        while (mutation_time_passed + time_mutation_event <= amplification_time_passed) {


            double index_mutated_monomer = int(uniform_distrib(random_generator) * (outputs.monomers_dataset.size()));
            double index_mutated_nucleotide = int(uniform_distrib(random_generator) * (ancestor_monomer.toString().size()));

            //std::cout << std::endl << "Monomer : " << index_mutated_monomer << std::endl;
            //std::cout << std::endl << "Nucleotide : " << index_mutated_nucleotide << std::endl;

            monomers_dataset_iterator = outputs.monomers_dataset.begin() ;
            advance(monomers_dataset_iterator,index_mutated_monomer);

            std::string currently_mutated_sequence = dynamic_cast<bpp::BppString*>((*monomers_dataset_iterator)->getNodeProperty("sequence"))->toSTL();
            
            //std::cout << std::endl << "Substitution : " << currently_mutated_sequence[index_mutated_nucleotide] << " -> " << nucleotides[(substitution_model_distribs[currently_mutated_sequence[index_mutated_nucleotide]])(random_generator)] << std::endl;

            *(currently_mutated_sequence.begin()+index_mutated_nucleotide) = nucleotides[(substitution_model_distribs[currently_mutated_sequence[index_mutated_nucleotide]])(random_generator)] ;


            (*monomers_dataset_iterator)->setNodeProperty("sequence", bpp::BppString(currently_mutated_sequence));


            mutation_time_passed = mutation_time_passed + time_mutation_event;
            time_mutation_event = mutation_distrib(random_generator) ;
        }

        /**< Prints or not the monomers dataset depending on the verbosity level. */
        if (verbose > 0){
            std::cout << std::endl << "Amplification size : " << amplification_size << std::endl;
            std::cout << "HOR order: " << HOR_order << std::endl;
            std::cout << "Index head monomer to amplify: " << index_head_monomers_to_amplify << std::endl << std::endl;


            std::cout << "Id" << "\t" << "Name" << "\t" << "Amplification_ID" << "\t" << "Parent_name" << "\t" << "Sequence" << std::endl << std::endl;
            monomers_dataset_iterator = outputs.monomers_dataset.begin() ;
            std::for_each (monomers_dataset_iterator, std::next(monomers_dataset_iterator,outputs.monomers_dataset.size()), [&outputs](bpp::Node* m) { std::cout << m->getId() << "\t" << m->getName() << "\t" << (dynamic_cast<bpp::BppInteger*>(m->getNodeProperty("amplification_id")))->getValue() << "\t" << *(dynamic_cast<bpp::BppString*>(m->getNodeProperty("parent_name"))) << "\t" << *dynamic_cast<bpp::BppString*>(m->getNodeProperty("sequence")) << std::endl << std::endl << std::endl; });
            std::cout << std::endl;
        }
        

        


    }

    //TODO : Remove once benchmarking done
    //std::cout << "\n\n------ Create time : " << time_create << " ------";
    //std::cout << "\n\n------ Replacement time : " << time_replace << " ------";
    //std::cout << "\n\n------ Insertion time : " << time_insert << " ------";

    return outputs ;
}

/** @brief Main function
*
* Main function in charge of the overall execution of the script including the execution of the argument parsing function , the simulation functions and the output generation functions.
*
* @param argc Number of arguments provided by the user in the command line.
* @param argv List of arguments provided by the user in the command line.
*
* @return 0 if normal execution, other number if error.
*/
int main(int argc, char **argv) {

    //TODO : Remove once bechmarking done
    //std::clock_t start, end;
    //std::cout << "\n-----------------------------------------------------------------------------------\n\n" << std::endl;

    /**< Stores the arguments for this execution of the script parsed by the get_args function. */
    Args args = get_args(argc, argv);

    bpp::Fasta fasta = bpp::Fasta();
    std::shared_ptr<const bpp::Alphabet> alpha = bpp::AlphabetTools::DNA_ALPHABET;
    bpp::Sequence ancestor_monomer = bpp::Sequence(alpha);
    std::ifstream ancestor_monomer_input_stream(args.input);
    fasta.nextSequence(ancestor_monomer_input_stream, ancestor_monomer);

    if (args.verbose > 2) std::cout << "Ancestor monomer : " << std::endl << std::endl << ancestor_monomer.getName() << std::endl << ancestor_monomer.toString() << std::endl << std::endl;

    //TODO : Remove once bechmarking done
    //start = std::clock();

    /**< Stores the Output_data structure containing the tree and the monomers dataset generated by the amplification simulation. */
    Output_data outputs = amplification_simulation(args.max_size, args.amplification_rate, args.alpha_amplification_size, args.beta_amplification_size, args.min_amplification_size, args.max_amplification_size, args.alpha_HOR_order, args.beta_HOR_order, args.min_HOR_order, args.max_HOR_order, ancestor_monomer, alpha, args.substitution_rate, args.transition_transversion_ratio, args.seed, args.verbose-1) ;

    //TODO : Remove once bechmarking done
    //end = std::clock();
    //std::cout << "\n\n------ Simulation time : " << ((double) (end - start)) / CLOCKS_PER_SEC << " ------" << std::endl;

    if (args.verbose > 0) std::cout << "Amplification simulation done." << std::endl << std::endl;

    //TODO : Remove once bechmarking done
    //start = std::clock();

    
    /**< Creates the object allowing to export the tree to a NHX formated file. */
    bpp::Nhx nhxWriter = bpp::Nhx(false) ;

    /**< Adds the amplification id as a registred property that will be written for each node in the NHX file. */
    nhxWriter.registerProperty(bpp::Nhx::Property("amplification_id","XN",false,1));


    if (args.output_option == 1 || args.output_option == 3) {
        /**< Writes the tree to the output file chosen by the user. */
        nhxWriter.writeTree(*(outputs.tree),args.tree_output_path,true);
    }

    /**< Writes the monomers dataset to the fasta output file chosen by the user. */
    std::ofstream monomers_dataset_output_stream(args.monomers_dataset_output_path);
    std::list<bpp::Node*>::iterator monomers_dataset_iterator = outputs.monomers_dataset.begin() ;
    std::for_each (monomers_dataset_iterator, std::next(monomers_dataset_iterator,outputs.monomers_dataset.size()), [&outputs, &monomers_dataset_output_stream](bpp::Node* m) { monomers_dataset_output_stream << ">" << m->getName() << " " << "A_" << (dynamic_cast<bpp::BppInteger*>(m->getNodeProperty("amplification_id")))->getValue() << "\n" << *dynamic_cast<bpp::BppString*>(m->getNodeProperty("sequence")) << std::endl; });


    //TODO : Remove once bechmarking done
    //end = std::clock();
    //std::cout << "\n\n------ Write time : " << ((double) (end - start)) / CLOCKS_PER_SEC << " ------\n\n" << std::endl;

    /**< Prints or not the monomers dataset and the NHX formated tree depending on the verbosity level. */
    if (args.verbose > 0){
        /**< Monomers dataset */
        std::cout << "Id" << "\t" << "Name"  << "\t" << "Amplification_ID" << "\t" << "Parent_name" << "\t" << "Sequence" << std::endl << std::endl;
        monomers_dataset_iterator = outputs.monomers_dataset.begin() ;
        std::for_each (monomers_dataset_iterator, std::next(monomers_dataset_iterator,outputs.monomers_dataset.size()), [&outputs](bpp::Node* m) { std::cout << m->getId() << "\t" << m->getName() << "\t" << (dynamic_cast<bpp::BppInteger*>(m->getNodeProperty("amplification_id")))->getValue() << "\t" << *(dynamic_cast<bpp::BppString*>(m->getNodeProperty("parent_name"))) << "\t" << *dynamic_cast<bpp::BppString*>(m->getNodeProperty("sequence")) << std::endl << std::endl << std::endl; });
        std::cout << std::endl << std::endl;
    
        /**< NHX formated tree */
        std::cout << nhxWriter.treeToParenthesis(*(outputs.tree)) << std::endl;

        std::cout << "Writing done." << std::endl;
    }

    return 0;
}