/**
* @file data_description.cc
* @brief Observed and simulated data description.
* @author Adelin BODNAR
* @date 13/05/2024
*
* Script used to generate statistics used to describe and compare the observed and simulated data.
*
*/

#include <algorithm> //std::min
#include <bits/stdc++.h>
#include <Bpp/Seq/Alphabet/AlphabetTools.h> //bpp::Alphabet, bpp::AlphabetTools
#include <Bpp/Seq/Io/Fasta.h>   //bpp::Fasta
#include <cctype> //std::tolower
#include <filesystem>   //std::filesystem::path, std::filesystem::exists, std::filesystem::is_directory
#include <getopt.h> //getopt_long 
#include <memory>   //std::shared_ptr<>
#include <string> //std::string


/** @brief Parsed arguments structure
* 
* Structure used to store the arguments provided by the user in the command line after parsing.
*/
struct Args {

    int verbose ; /**< Integer used to determine the level of verbosity for the execution of the script */

    std::string input ; /**< String containing the path provided by the user to the input fasta file with the aligned monomers dataset */

    int nb_comparisons_per_monomer; /**< Integer used to determine the number of monomers after in the ordered dataset that each monomer will be compared to */

    int seed; /**< Integer variable used to initialize the random number generators. */

    std::string sum_stats_output_path ; /**< String containing the path to the output file generated by the script with the different summary statistics generated from the pairwise comparison of the sequences in the input file */

};

/** @brief Parsing the arguments.
*
* Function parsing the arguments provided by the user in the command line and storing them in the structure defined above.
*
* @param argc The number of arguments provided by the user in the command line.
* @param argv The list of arguments provided by the user in the command line.
*
* @return parsed_args an instance of the Args structure containing the arguments provided by the user and used as parameters for multiple parts of the simulation script
*/
Args get_args(int argc, char **argv) {

    //Initializing parsed_args and default values for some of its attributes

    Args parsed_args ;  /**< Variable used to store and return the arguments provided by the user after parsing */

    parsed_args.verbose = 0;   /**< Initializes the default verbosity level at 0 */

    parsed_args.nb_comparisons_per_monomer = 50; /**< Initializes the default number of next monomers in the ordered dataset that each monomer will be compared to at 50. */

    parsed_args.seed = std::time(0) ; /**< Initializes the default seed at the current time in seconds. */

    std::filesystem::path summary_statistics_dir_path ; /**< Declares the path variable used to store the path to the directory that will contain the summary statistics output file. */


    /**< String containing the help message printed when the -h , --help or a wrong option are provided ny the user */
    const std::string usage = "Usage: \n"
                            "\t./data_description [-h] -i INPUT [--seed SEED] [--sum_stats_output_path SUM_STATS_OUTPUT_PATH] [-v | --verbose | --no-verbose]\n\n"

                            "\toptions:\n\n"

                            "\t-h, --help \n\t\tOption showing this help message and exiting\n\n"

                            "\t-i INPUT, --input INPUT\n"
                            "\t\tArgument defining the input fasta file containing the \n"
                            "\t\taligned monomers compared to generate the summary statistics \n\n"

                            "\t--seed SEED \n"
                            "\t\tArgument defining the seed used to initialize the random \n"
                            "\t\tnumber generator \n\n"

                            "\t--nb_comparisons_per_monomer NB_COMPARISONS_PER_MONOMER \n"
                            "\t\tArgument defining the number of monomers after in the ordered dataset \n"
                            "\t\tthat each monomer will be compared to \n\n"

                            "\t--sum_stats_output_path SUM_STATS_OUTPUT_PATH \n"
                            "\t\tArgument defining the path to the phylogenic tree \n"
                            "\t\toutput file \n\n"

                            "\t-v, --verbose, --no-verbose \n"
                            "\t\tOptions allowing to print or not the script execution \n"
                            "\t\tsupervision prints (tree and list after each amplification event) \n\n" ;


    /** @brief Long options defining structure
    *
    * Structure used by the function getopt_long to define, parse and link to their short versions the long options for the simulation script.
    */
    const struct option long_options[] =
        {
          // These options donâ€™t set a flag. We distinguish them by their indices. 

          {"seed", required_argument, 0, 0},

          {"nb_comparisons_per_monomer", required_argument, 0, 0},

          {"sum_stats_output_path", required_argument, 0, 0},

          //  These options set flags. 

          {"help", no_argument, 0, 'h'},

          {"input", required_argument, 0, 'i'},

          {"verbose", no_argument, 0, 'v'},

          {0, 0, 0, 0}
        };

    // getopt_long stores the option index here.
    int option_index;

    int c;

    while ((c = getopt_long (argc, argv, "hi:v", long_options, &option_index)) != -1) {

        switch (c)
        {
            case 'i':

                //std::cout << "Input: " << optarg << std::endl;
                if (std::filesystem::exists(optarg)) {
                    //std::cout << "Input file found.\n" << std::endl;
                    parsed_args.input = optarg;
                }else{
                    std::cout << "No such input file.\n" << std::endl;
                    std::cout << usage.c_str();
                    exit(1);
                }

                break;

            case 'v':
                
                parsed_args.verbose ++ ;
               
                break;

            case 0 :
                
                switch (option_index){

                    case 0 :

                        //std::cout << "Seed: " << optarg << std::endl << std::endl;
                        parsed_args.seed = std::stoi(optarg);

                        break;

                    case 1 :

                        //std::cout << "Nb comparisons per monomer: " << optarg << std::endl << std::endl;
                        parsed_args.nb_comparisons_per_monomer = std::stoi(optarg);

                        break;

                    case 2 :

                        //std::cout << "Summary statistics output path: " << optarg << std::endl << std::endl;
                        summary_statistics_dir_path = std::filesystem::path(optarg).parent_path();
                        if (std::filesystem::exists(summary_statistics_dir_path) && std::filesystem::is_directory(summary_statistics_dir_path)) {
                            if (std::filesystem::exists(optarg)) {
                                std::cout << "Pre-existing file found. It will be replaced by the newly generated output file." << std::endl << std::endl;
                            }
                            parsed_args.sum_stats_output_path = optarg;
                        
                        }else{
                            std::cout << "No such tree output directory." << std::endl << std::endl;
                            std::cout << usage.c_str();
                            exit(1);
                        }

                        break;

                    default:

                        exit(1);

                }

                break;

            case '?':
            case 'h':

                std::cout << std::endl;
                std::cout << usage.c_str();
                
                exit(1);

            default:

                exit(1);
        }

    }

    if (parsed_args.input.empty()){
        std::cout << "Input argument is required.\n" << std::endl;
        std::cout << usage.c_str();
        exit(1);
    }

    if (parsed_args.sum_stats_output_path.empty()){
        parsed_args.sum_stats_output_path = parsed_args.input + ".sum_stats.txt" ;
    }


    /**< Prints the simulation parameters to the terminal if needed. */
    if (parsed_args.verbose > 0) {

        std::cout << "Input: " << parsed_args.input << std::endl;

        std::cout << "Seed: " << parsed_args.seed << std::endl;

        std::cout << "Nb comparisons per monomer: " << parsed_args.nb_comparisons_per_monomer << std::endl;

        std::cout << "Summary statistics output path: " << parsed_args.sum_stats_output_path << std::endl;

        std::cout << "Verbosity level: " << parsed_args.verbose << std::endl << std::endl;
    }

    return parsed_args;
}

/** @brief Parsing the arguments.
*
* Function comparing two strings (supposed to be DNA sequences) to return the corresponding similarity percentage .
*
* @param input_file_path String containing the path to the input file containing the aligned monomers ordered dataset.
* @param list_sequences_ptr Pointer allowing to access the vector in which we want to store the parsed sequences from the input file as strings.
*
* @return void
*/
void parse_input_fasta(std::string input_file_path, std::vector<std::string>* list_sequences_ptr ) {

    bpp::Fasta fasta = bpp::Fasta();
    std::shared_ptr<const bpp::Alphabet> alpha = bpp::AlphabetTools::DNA_ALPHABET;
    bpp::Sequence monomer_sequence = bpp::Sequence(alpha);
    std::ifstream monomers_input_stream(input_file_path);
    while(monomers_input_stream){
        fasta.nextSequence(monomers_input_stream, monomer_sequence);
        list_sequences_ptr->push_back(monomer_sequence.toString());
    }

}

/** @brief Calculate similarity of two sequences.
*
* Function comparing two strings (supposed to be DNA sequences) to return the corresponding similarity percentage .
*
* @param seq_1_ptr Pointer allowing to access the first sequence of the pair we want to compare.
* @param seq_2_ptr Pointer allowing to access the second sequence of the pair we want to compare.
*
* @return the similarity percentage for this pair of sequences
*/
double get_similarity(std::string* seq_1_ptr, std::string* seq_2_ptr) {

    if (seq_1_ptr->length() == seq_2_ptr->length()){

        double hamming_distance = 0 ;

        if (seq_1_ptr->find('-') != std::string::npos || seq_2_ptr->find('-') != std::string::npos) {

            int gaps = 0;

            for(int i = 0; i < seq_1_ptr->length(); i++){

                if ((*seq_1_ptr)[i] == '-' || (*seq_2_ptr)[i] == '-') {
                    gaps++;
                }else if ((*seq_1_ptr)[i] != (*seq_2_ptr)[i]){
                    hamming_distance++;
                }
            }

            return (seq_1_ptr->length() - gaps - hamming_distance)/(std::max(int(seq_1_ptr->length() - gaps), 1)) ;

        }else{
        
            for(int i = 0; i < seq_1_ptr->length(); i++){
                if ((*seq_1_ptr)[i] != (*seq_2_ptr)[i]) hamming_distance++;
            }

            return (seq_1_ptr->length()-hamming_distance)/(seq_1_ptr->length()) ;

        }

    }else{

        std::cout << "Different size of sequences" << std::endl;
        exit(1);
    
    }
}

/** @brief Compare each monomer to N next monomers.
*
* Function comparing string from the list of sequences to the N next string in the list in order to return the position with maximum similarity value for each of them .
*
* @param nb_monomers_to_compare Integer defining the number of the sequences we want to compare each monomer to.
* @param list_sequences Pointer allowing to access the list of sequences used for the comparisons.
* @param HOR_order_distribution Pointer allowing to access the list used to store the results.
*
*/
void compare_monomers_to_next (int nb_monomers_to_compare, std::vector<std::string>* list_sequences, std::vector<int>* HOR_order_distribution ) {

    double max_similarity;
    double new_similarity;
    int estimated_order;
    

    for(int i = 0; i < list_sequences->size()-1; i++){

        max_similarity = -1;
        estimated_order = 0;

        for(int j = 1+i; j < std::min(nb_monomers_to_compare+1+i, int(list_sequences->size())); j++){

            new_similarity = get_similarity(&((*list_sequences)[i]), &((*list_sequences)[j]));

            if (new_similarity > max_similarity) {

            estimated_order = j-i;
            max_similarity = new_similarity;

            }

        }

        if (estimated_order != 0) {
            (*HOR_order_distribution)[estimated_order-1] += 1;
        }else{
            exit(1);
        }

    }
    
}

/** @brief Compare each monomer to a random other monomer.
*
* Function comparing string from the list of sequences to a random other string in the list in order to return a similarity value for each of them .
*
* @param seed Integer defining the seed used to initialize the random number generator.
* @param list_sequences Pointer allowing to access the list of sequences used for the comparisons.
* @param similarity_distribution Pointer allowing to access the list used to store the results.
*
*/
void compare_monomers_to_random (int seed, std::vector<std::string>* list_sequences, std::vector<int>* similarity_distribution ) {

    double similarity;
    int index_random_monomer;

    /**< Initializes srand using the seed provided by the user. */
    srand(seed);
    /**< Initializes a mersenne twister type random number generator seeded by a number from the srand seeded by the user. */
    std::mt19937 random_generator(rand());
      /**< Initializes a uniform distribution used to draw random indexes during the simulation. */
    std::uniform_real_distribution<double> uniform_distrib = std::uniform_real_distribution<double>(0,1);

    for(int i = 0; i < list_sequences->size()-1; i++){

        do { index_random_monomer = int(uniform_distrib(random_generator) * (list_sequences->size() -1)); } while ( i == index_random_monomer);

        similarity = get_similarity(&((*list_sequences)[i]), &((*list_sequences)[index_random_monomer]));

        (*similarity_distribution)[int(similarity * 100)] += 1;

    }

}


/** @brief Generates summary statistics for the list of sequences provided.
*
* Function generating summary statistics for strings from the list of sequences and returning them in one line .
*
* @param nb_monomers_to_compare Integer defining the number of the next sequences in the list we want to compare each monomer to.
* @param seed Integer defining the seed used to initialize the random number generator.
* @param list_sequences Pointer allowing to access the list of sequences used for the comparisons.
*
* @return the string containing the summary statistics generated.
*/
std::string generate_summary_stats (int nb_monomers_to_compare, int seed, std::vector<std::string>* list_sequences ) {

    std::string summary_stats = "";

    std::vector<int> HOR_order_distribution (nb_monomers_to_compare,0);

    compare_monomers_to_next (nb_monomers_to_compare, list_sequences, &HOR_order_distribution);

    summary_stats.append("order_distrib\t");

    for (int i = 0; i < HOR_order_distribution.size(); i++ ){
        summary_stats += std::to_string(HOR_order_distribution[i]) + "\t";
    }

    std::vector<int> similarity_distribution (101,0);

    compare_monomers_to_random (seed, list_sequences, &similarity_distribution);

    summary_stats.append("similarity_distrib\t");

    for (int i = 0; i < similarity_distribution.size(); i++ ){
        summary_stats += std::to_string(similarity_distribution[i]) + "\t";
    }

    return summary_stats;

}




/** @brief Main function
*
* Main function in charge of the overall execution of the script.
*
* @param argc Number of arguments provided by the user in the command line.
* @param argv List of arguments provided by the user in the command line.
*
* @return 0 if normal execution, other number if error.
*/
int main(int argc, char **argv) {

    Args args = get_args(argc, argv);

    std::vector<std::string> list_sequences;

    parse_input_fasta(args.input, &list_sequences);

    std::string summary_stats = generate_summary_stats(args.nb_comparisons_per_monomer, args.seed, &list_sequences);

    std::cout << summary_stats << std::endl;

    

    return 0;
}